ğŸ§± CREACIÃ“N DE MIGRACIONES

php artisan migrate --path=database/migrations/2025_07_25_000000_create_roles_table.php

php artisan db:seed --class=RolesAndPermissionsSeeder

php artisan make:migration nombre_de_la_migracion
Ejemplo:
php artisan make:migration create_roles_table

php artisan make:migration nombre_de_la_migracion --create=tabla
Ejemplo:
php artisan make:migration create_users_table --create=users

php artisan make:migration nombre_de_la_migracion --table=tabla
(Ejemplo para modificar una tabla existente)
php artisan make:migration add_email_to_users_table --table=users

ğŸ“¦ CREAR MIGRACIÃ“N CON MODELO

php artisan make:model NombreModelo -m
Ejemplo:
php artisan make:model Role -m
(Este comando crea el modelo `Role` y su migraciÃ³n asociada)

ğŸš€ EJECUTAR MIGRACIONES

php artisan migrate
Ejecuta todas las migraciones pendientes

php artisan migrate --path=database/migrations/nombre_archivo.php
Ejecuta una migraciÃ³n especÃ­fica ubicada fuera del directorio convencional

ğŸ” REVERTIR MIGRACIONES

php artisan migrate:rollback
Revierte la Ãºltima tanda de migraciones

php artisan migrate:rollback --step=2
Revierte las Ãºltimas 2 tandas de migraciones

php artisan migrate:reset
Revierte todas las migraciones

ğŸ”„ REFRESCAR MIGRACIONES

php artisan migrate:refresh
Resetea y vuelve a correr todas las migraciones

php artisan migrate:refresh --seed
Igual que el anterior, pero corre los seeders luego

ğŸ§¹ RECREAR TODO DESDE CERO

php artisan migrate:fresh
Elimina todas las tablas y ejecuta las migraciones de nuevo

php artisan migrate:fresh --seed
Igual que el anterior, pero tambiÃ©n corre los seeders

ğŸ•µï¸â€â™‚ï¸ ESTADO DE LAS MIGRACIONES

php artisan migrate:status
Muestra quÃ© migraciones ya se ejecutaron y cuÃ¡les no

âœ… MIGRAR UNA TABLA ESPECÃFICA EN LARAVEL

Si necesitas migrar una tabla primero (por ejemplo `roles`), sin tocar las demÃ¡s, usa:

php artisan migrate --path=database/migrations/AAAA_MM_DD_HHmmss_create_roles_table.php

(Reemplaza la fecha y nombre por el de tu archivo real)

âš™ Luego puedes migrar el resto con:

php artisan migrate

Laravel detectarÃ¡ que la tabla `roles` ya estÃ¡ migrada y ejecutarÃ¡ solamente las pendientes.

---

ğŸ’¡ VENTAJAS DE MIGRAR ROLES PRIMERO

- Evitas errores de clave forÃ¡nea no existente en `users`.
- No necesitas renombrar archivos ni modificar timestamps.
- Mantienes el orden original y la integridad de la base de datos.

---

ğŸ§  REGLA CLAVE EN LARAVEL

La tabla que contiene la clave forÃ¡nea (FK) pertenece a la tabla principal y se debe migrar despuÃ©s.

Ejemplo:

- Tabla `users` tiene `role_id` â†’ `users` pertenece a `roles`
- Por eso, `roles` debe migrarse primero

---

ğŸ” REVERTIR MIGRACIONES (si necesitas empezar desde cero)

php artisan migrate:reset        â† Revierte todas las migraciones  
php artisan migrate:rollback     â† Revierte la Ãºltima tanda  
php artisan migrate:fresh        â† Borra todo y vuelve a migrar  
php artisan migrate:fresh --seed â† Borra todo, migra y ejecuta seeders  























ğŸ§© TIPOS DE RELACIONES EN LARAVEL Y EJEMPLOS

1ï¸âƒ£ RelaciÃ³n Uno a Uno (One to One)

- MÃ©todo: hasOne() / belongsTo()

Ejemplo:

// En modelo User
public function profile() {
    return $this->hasOne(Profile::class);
}

// En modelo Profile
public function user() {
    return $this->belongsTo(User::class);
}

Notas:
- La tabla secundaria debe tener una FK apuntando a la principal (profile.user_id).
- Es Ãºtil para datos que se extienden de una sola entidad.

2ï¸âƒ£ RelaciÃ³n Uno a Muchos (One to Many)

- MÃ©todo: hasMany() / belongsTo()

Ejemplo:

// En modelo Role
public function users() {
    return $this->hasMany(User::class);
}

// En modelo User
public function role() {
    return $this->belongsTo(Role::class);
}

Notas:
- La tabla hija tiene la FK (users.role_id).
- Muy comÃºn en roles, categorÃ­as, etc.

3ï¸âƒ£ RelaciÃ³n Muchos a Uno (Many to One)

- MÃ©todo: belongsTo()

Ejemplo:

// En modelo User
public function aldea() {
    return $this->belongsTo(Aldea::class);
}

Notas:
- Es la perspectiva inversa del One to Many.
- La FK sigue estando en el modelo actual.

4ï¸âƒ£ RelaciÃ³n Muchos a Muchos (Many to Many)

- MÃ©todo: belongsToMany()

Ejemplo:

// En modelo Estudiante
public function unidadesCurriculares() {
    return $this->belongsToMany(UnidadCurricular::class, 'notas');
}

// En modelo UnidadCurricular
public function estudiantes() {
    return $this->belongsToMany(Estudiante::class, 'notas');
}

Notas:
- Requiere tabla intermedia (pivot).
- Puedes acceder a los datos extras de la tabla intermedia con ->withPivot('campo').

5ï¸âƒ£ RelaciÃ³n Uno a Muchos Inversa (Inverse hasMany)

- MÃ©todo: belongsTo()

Ejemplo:

// En modelo User
public function coordinador() {
    return $this->hasOne(Coordinador::class);
}

// En modelo Coordinador
public function user() {
    return $this->belongsTo(User::class);
}

Notas:
- Similar a One to One, pero con posibilidad de usar hasMany en el principal si hay varios.

6ï¸âƒ£ Relaciones con Clave Compuesta (No soportadas nativamente)

Notas:
- Laravel no soporta claves primarias compuestas para relaciones.
- SoluciÃ³n: crear relaciones manuales o diseÃ±ar la tabla pivot con su propio ID.

7ï¸âƒ£ Uso de with() para cargar relaciones (Eager Loading)

Ejemplo:

$users = User::with('role')->get();

Notas:
- Reduce nÃºmero de consultas.
- Se usa en controladores para traer relaciones asociadas.

8ï¸âƒ£ withCount() para contar relaciones

Ejemplo:

$roles = Role::withCount('users')->get();

Notas:
- Muy Ãºtil para estadÃ­sticas rÃ¡pidas (usuarios por rol, etc.).

9ï¸âƒ£ Cargar mÃºltiples relaciones

Ejemplo:

$estudiantes = Estudiante::with(['user', 'notas.unidadCurricular'])->get();

Notas:
- Puedes cargar relaciones anidadas.

ğŸ”’ Recomendaciones finales

âœ” Siempre define bien la FK en las migraciones (`foreignId('rol_id')->constrained()`).

âœ” Usa nombres coherentes para las funciones en los modelos (evita ambigÃ¼edades).

âœ” Recuerda usar factories y seeders para probar las relaciones.

âœ” Documenta cada relaciÃ³n con su sentido funcional.

